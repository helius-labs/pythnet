#![feature(drain_filter)]
#![feature(generic_associated_types)]
#![feature(iterator_try_reduce)]

use {
    ciborium::value::Value,
    slow_primes::is_prime_miller_rabin,
    solana_merkle_tree::merkle_tree,
    std::{
        collections::HashSet,
        iter::Iterator,
        mem::size_of,
    },
};

trait Accumulator<'a>: Sized {
    type Proof: 'a;
    fn prove(&'a self, item: &[u8]) -> Option<Self::Proof>;
    fn verify(&'a self, proof: Self::Proof, item: &[u8]) -> Option<bool>;
    fn from_set(items: impl Iterator<Item = &'a &'a [u8]>) -> Option<Self>;
}

// ------------------------------------------------------------------------------

mod accumulators {
    use super::*;

    pub fn hash_to_prime(bytes: &[u8]) -> u128 {
        // Scan for prime's generated by hashing the bytes starting from 0. We use a number like
        // this so once the prime is found we can directly compute the hash instead of scanning
        // the range again.
        let mut search = 0usize;

        loop {
            // Increment Search Counter.
            search += 1;

            // Hash Input.
            let mut hasher = <sha2::Sha256 as digest::Digest>::new();
            digest::Digest::update(&mut hasher, bytes);
            digest::Digest::update(&mut hasher, &search.to_be_bytes());
            let hash_bytes: [u8; 32] = digest::Digest::finalize(hasher).into();

            // Take only a u32 from the end, return if it's prime.
            let prime = u32::from_be_bytes(hash_bytes[28..].try_into().unwrap()) | 1;
            if is_prime_miller_rabin(prime as u64) {
                return prime as u128;
            }
        }
    }

    pub mod mul {
        use {
            super::hash_to_prime,
            crate::*,
        };

        pub struct MulAccumulator {
            pub accumulator: u128,
            pub items:       Vec<u128>,
        }

        impl<'a> Accumulator<'a> for MulAccumulator {
            type Proof = u128;

            fn from_set(items: impl Iterator<Item = &'a &'a [u8]>) -> Option<Self> {
                let primes: Vec<u128> = items.map(|i| hash_to_prime(i)).collect();
                Some(Self {
                    items:       primes.clone(),
                    accumulator: primes.into_iter().reduce(|acc, v| acc * v)?,
                })
            }

            fn verify(&self, proof: Self::Proof, item: &[u8]) -> Option<bool> {
                let bytes = hash_to_prime(item);
                Some(proof * bytes as u128 == self.accumulator)
            }

            fn prove(&self, item: &[u8]) -> Option<Self::Proof> {
                let bytes = hash_to_prime(item);
                Some(self.accumulator / bytes as u128)
            }
        }
    }

    pub mod merkle {
        use {
            crate::*,
            solana_merkle_tree::{
                merkle_tree::Proof,
                MerkleTree,
            },
            solana_sdk::hash::hashv,
        };

        macro_rules! hash_leaf {
            {$d:ident} => {
                hashv(&[&[0], $d])
            }
        }

        pub struct MerkleAccumulator<'a> {
            pub accumulator: MerkleTree,
            pub items:       Vec<&'a [u8]>,
        }

        impl<'a> Accumulator<'a> for MerkleAccumulator<'a> {
            type Proof = Proof<'a>;

            fn from_set(items: impl Iterator<Item = &'a &'a [u8]>) -> Option<Self> {
                let items: Vec<&[u8]> = items.copied().collect();
                let tree = solana_merkle_tree::MerkleTree::new(&items);
                Some(Self {
                    accumulator: tree,
                    items,
                })
            }

            fn verify(&self, proof: Self::Proof, item: &[u8]) -> Option<bool> {
                let item = hash_leaf!(item);
                Some(proof.verify(item))
            }

            fn prove(&'a self, item: &[u8]) -> Option<Self::Proof> {
                let index = self.items.iter().position(|i| i == &item)?;
                self.accumulator.find_path(index)
            }
        }
    }
}

#[derive(Default, Debug, serde::Serialize, serde::Deserialize)]
struct PriceAccount {
    pub id:         u64,
    pub price:      u64,
    pub price_expo: u64,
    pub ema:        u64,
    pub ema_expo:   u64,
}

#[derive(Default, Debug, serde::Serialize, serde::Deserialize)]
struct PriceOnly {
    pub price_expo: u64,
    pub price:      u64,
    pub id:         u64,
}

impl From<PriceAccount> for PriceOnly {
    fn from(other: PriceAccount) -> Self {
        Self {
            id:         other.id,
            price:      other.price,
            price_expo: other.price_expo,
        }
    }
}

fn main() {
    use accumulators::{
        merkle::MerkleAccumulator,
        mul::MulAccumulator,
    };

    let mut set: HashSet<&[u8]> = HashSet::new();

    // Create some random elements (converted to bytes). All accumulators store arbitrary bytes so
    // that we can target any account (or subset of accounts).
    let item_a = 33usize.to_be_bytes();
    let item_b = 54usize.to_be_bytes();
    let item_c = 2usize.to_be_bytes();
    let item_d = 88usize.to_be_bytes();

    // Insert the bytes into the Accumulate type.
    set.insert(&item_a);
    set.insert(&item_b);
    set.insert(&item_c);

    println!();

    // Create an Accumulator. Test Membership.
    {
        let accumulator = MulAccumulator::from_set(set.iter()).unwrap();
        let proof = accumulator.prove(&item_a).unwrap();
        println!("Mul:");
        println!("Proof:  {:?}", accumulator.verify(proof, &item_a));
        println!("Proof:  {:?}", accumulator.verify(proof, &item_d));
    }

    // Again, but with Merkle Trees.
    {
        println!();
        let accumulator = MerkleAccumulator::from_set(set.iter()).unwrap();
        println!("Merkle:");
        let proof = accumulator.prove(&item_a).unwrap();
        println!("Valid:  {:?}", accumulator.verify(proof, &item_a));
        let proof = accumulator.prove(&item_a).unwrap();
        println!("Fails:  {:?}", accumulator.verify(proof, &item_d));
        println!("Size:   {:?}", size_of::<merkle_tree::Proof>());
    }

    println!(
        "\n--------------------------------------------------------------------------------\n"
    );

    // Serialize with cborium into a Value. We can dynamically drop fields from this.
    let price = PriceAccount {
        id:         1283,
        price:      1288,
        price_expo: 8,
        ema:        1288,
        ema_expo:   8,
    };

    println!("Before: {:?}", price);

    let mut price = ciborium::value::Value::serialized(&price).unwrap();

    // Drop anything except "id", "price", "price_expo" to compress the wire format.
    let allowed_keys = ["id", "price", "price_expo"].map(ciborium::value::Value::from);
    let price = ciborium::value::Value::from(
        price
            .as_map_mut()
            .unwrap()
            .drain_filter(|(key, _)| allowed_keys.contains(key))
            .collect::<Vec<(Value, Value)>>(),
    );

    // Serialize with cborium.
    let buf = Vec::new();
    let mut cur = std::io::Cursor::new(buf);
    let _ = ciborium::ser::into_writer(&price, &mut cur);

    // Deserialize with cborium
    let _ = std::io::Seek::rewind(&mut cur);
    println!("Size:   {:?}", cur.clone().into_inner().len());
    let r: PriceOnly = ciborium::de::from_reader(cur).unwrap();
    println!("Decode: {:?}", r);
    println!();
}
